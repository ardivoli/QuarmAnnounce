{"id":"QuarmAnnounce-30w","title":"Add find_most_recent_log() helper function","description":"In src/log_monitor.rs, add a new helper function and constants:\n\n1. Add these constants near the top of the file (after existing constants):\n```rust\nconst LOG_FILE_PREFIX: \u0026str = \"eqlog_\";\nconst MTIME_CHECK_INTERVAL: Duration = Duration::from_secs(1);\n```\n\n2. Add a helper function (can be a standalone fn or impl method):\n```rust\n/// Scans the given directory for eqlog_* files and returns the most recently modified one.\n/// Returns None if no matching log files are found.\nfn find_most_recent_log(directory: \u0026Path) -\u003e Result\u003cOption\u003cPathBuf\u003e\u003e {\n    let entries = std::fs::read_dir(directory)\n        .context(format!(\"Failed to read directory: {}\", directory.display()))?;\n    \n    let mut most_recent: Option\u003c(PathBuf, std::time::SystemTime)\u003e = None;\n    \n    for entry in entries.filter_map(|e| e.ok()) {\n        let file_name = entry.file_name();\n        let name_str = file_name.to_string_lossy();\n        \n        if name_str.starts_with(LOG_FILE_PREFIX) {\n            if let Ok(metadata) = entry.metadata() {\n                if let Ok(mtime) = metadata.modified() {\n                    match \u0026most_recent {\n                        None =\u003e most_recent = Some((entry.path(), mtime)),\n                        Some((_, prev_mtime)) if mtime \u003e *prev_mtime =\u003e {\n                            most_recent = Some((entry.path(), mtime));\n                        }\n                        _ =\u003e {}\n                    }\n                }\n            }\n        }\n    }\n    \n    Ok(most_recent.map(|(path, _)| path))\n}\n```\n\nNote: This uses std::fs (sync) which is fine since directory scanning is fast. Add 'use std::path::Path;' if not already imported.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:25:51.286833-06:00","updated_at":"2026-01-06T16:28:49.671541-06:00","closed_at":"2026-01-06T16:28:49.671541-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-30w","depends_on_id":"QuarmAnnounce-ohe","type":"blocks","created_at":"2026-01-06T08:27:19.166692-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-42f","title":"Refactor LogMonitor to store game_directory","description":"In src/log_monitor.rs, modify the LogMonitor struct and its constructor:\n\n1. Change the struct field from log_path to game_directory:\nBEFORE:\n```rust\npub struct LogMonitor {\n    log_path: PathBuf,\n    message_map: HashMap\u003cString, String\u003e,\n    tts_engine: TtsEngine,\n}\n```\n\nAFTER:\n```rust\npub struct LogMonitor {\n    game_directory: PathBuf,\n    message_map: HashMap\u003cString, String\u003e,\n    tts_engine: TtsEngine,\n}\n```\n\n2. Update the constructor (LogMonitor::new):\nBEFORE:\n```rust\npub fn new(config: Config, tts_engine: TtsEngine) -\u003e Self {\n    Self {\n        log_path: PathBuf::from(config.log_file_path),\n        message_map: config.message_announcements,\n        tts_engine,\n    }\n}\n```\n\nAFTER:\n```rust\npub fn new(config: Config, tts_engine: TtsEngine) -\u003e Self {\n    Self {\n        game_directory: PathBuf::from(config.game_directory),\n        message_map: config.message_announcements,\n        tts_engine,\n    }\n}\n```\n\n3. Update test helper create_test_monitor() to use game_directory instead of log_path.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:26:08.71505-06:00","updated_at":"2026-01-06T16:28:49.672954-06:00","closed_at":"2026-01-06T16:28:49.672954-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-42f","depends_on_id":"QuarmAnnounce-ohe","type":"blocks","created_at":"2026-01-06T08:27:19.34621-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-n5s","title":"Update tests for directory-based monitoring","description":"In src/log_monitor.rs, update the test helper and tests to work with the new structure:\n\n1. Update create_test_monitor() helper (around line 185):\nBEFORE:\n```rust\nfn create_test_monitor(message_map: HashMap\u003cString, String\u003e) -\u003e LogMonitor {\n    LogMonitor {\n        log_path: PathBuf::from(\"/test/path\"),\n        message_map,\n        tts_engine: TtsEngine::new_mock().expect(\"Failed to create mock TTS engine\"),\n    }\n}\n```\n\nAFTER:\n```rust\nfn create_test_monitor(message_map: HashMap\u003cString, String\u003e) -\u003e LogMonitor {\n    LogMonitor {\n        game_directory: PathBuf::from(\"/test/game\"),\n        message_map,\n        tts_engine: TtsEngine::new_mock().expect(\"Failed to create mock TTS engine\"),\n    }\n}\n```\n\n2. Optionally add a new test for find_most_recent_log():\n```rust\n#[test]\nfn test_find_most_recent_log_no_files() {\n    // Create a temp directory with no eqlog files\n    let temp_dir = std::env::temp_dir().join(\"test_no_logs\");\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n    \n    let result = find_most_recent_log(\u0026temp_dir).unwrap();\n    assert!(result.is_none());\n    \n    std::fs::remove_dir_all(\u0026temp_dir).ok();\n}\n```\n\nNote: The existing process_one_batch tests don't need changes since they test the line processing logic which is unchanged.","status":"in_progress","priority":2,"issue_type":"task","created_at":"2026-01-06T08:27:13.771128-06:00","updated_at":"2026-01-06T16:29:09.040115-06:00","dependencies":[{"issue_id":"QuarmAnnounce-n5s","depends_on_id":"QuarmAnnounce-42f","type":"blocks","created_at":"2026-01-06T08:27:20.082524-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-ohe","title":"Update Config struct to use game_directory","description":"In src/main.rs, modify the Config struct (around line 16):\n\nBEFORE:\n```rust\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct Config {\n    pub log_file_path: String,\n    pub message_announcements: HashMap\u003cString, String\u003e,\n}\n```\n\nAFTER:\n```rust\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct Config {\n    pub game_directory: String,\n    pub message_announcements: HashMap\u003cString, String\u003e,\n}\n```\n\nAlso update the println! on line 45 from 'Log file:' to 'Game directory:' and change config.log_file_path to config.game_directory.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:25:31.961655-06:00","updated_at":"2026-01-06T16:28:37.090706-06:00","closed_at":"2026-01-06T16:28:37.090706-06:00","close_reason":"Closed"}
{"id":"QuarmAnnounce-pf1","title":"Implement mtime check loop with file switching","description":"In src/log_monitor.rs, rewrite the start_monitoring() method to:\n\n1. Track last mtime check time using std::time::Instant\n2. Find and open the most recent log file on startup\n3. Check for file switches every 1 second (when at EOF)\n\nNew start_monitoring() logic:\n```rust\npub async fn start_monitoring(\u0026self) -\u003e Result\u003c()\u003e {\n    println!(\"Scanning directory: {:?}\", self.game_directory);\n    \n    loop {\n        // Find the most recent log file\n        let log_path = match find_most_recent_log(\u0026self.game_directory)? {\n            Some(path) =\u003e path,\n            None =\u003e {\n                println!(\"No eqlog_* files found, waiting...\");\n                tokio::time::sleep(Duration::from_secs(1)).await;\n                continue;\n            }\n        };\n        \n        println!(\"Monitoring: {:?}\", log_path);\n        \n        // Open and seek to end\n        let file = tokio::fs::File::open(\u0026log_path).await\n            .context(format!(\"Failed to open: {}\", log_path.display()))?;\n        let mut reader = BufReader::new(file);\n        reader.seek(SeekFrom::End(0)).await?;\n        \n        // Monitor this file until a different file becomes most recent\n        let mut last_mtime_check = std::time::Instant::now();\n        \n        loop {\n            match self.process_one_batch(\u0026mut reader, \u0026mut String::new()).await? {\n                Some(announcements) =\u003e {\n                    // Spawn announcements...\n                    for announcement in announcements {\n                        let engine = self.tts_engine.clone();\n                        tokio::spawn(async move {\n                            if let Err(e) = engine.announce(\u0026announcement).await {\n                                eprintln!(\"Announce failed: {}\", e);\n                            }\n                        });\n                    }\n                }\n                None =\u003e {\n                    // EOF - check if we should switch files\n                    if last_mtime_check.elapsed() \u003e= MTIME_CHECK_INTERVAL {\n                        last_mtime_check = std::time::Instant::now();\n                        if let Some(new_path) = find_most_recent_log(\u0026self.game_directory)? {\n                            if new_path != log_path {\n                                println!(\"Switching to: {:?}\", new_path);\n                                break; // Break inner loop to reopen with new file\n                            }\n                        }\n                    }\n                    tokio::time::sleep(IDLE_RETRY_DELAY).await;\n                }\n            }\n        }\n    }\n}\n```\n\nKey points:\n- Outer loop handles file discovery/switching\n- Inner loop handles reading from current file\n- Check mtime only when at EOF and 1 second has elapsed\n- When switching, break inner loop to restart with new file","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:26:32.689246-06:00","updated_at":"2026-01-06T16:29:06.486355-06:00","closed_at":"2026-01-06T16:29:06.486355-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-pf1","depends_on_id":"QuarmAnnounce-30w","type":"blocks","created_at":"2026-01-06T08:27:19.533864-06:00","created_by":"daemon"},{"issue_id":"QuarmAnnounce-pf1","depends_on_id":"QuarmAnnounce-42f","type":"blocks","created_at":"2026-01-06T08:27:19.73819-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-qu0","title":"Update config.json to use game_directory","description":"Update config.json to use the new game_directory field:\n\nBEFORE:\n```json\n{\n  \"log_file_path\": \"./eqlog_YourCharacter_pq.proj.txt\",\n  \"message_announcements\": {\n    \"charm spell has worn off\": \"charm break\",\n    \"Root spell has worn off\": \"root break\",\n    \"Fetter spell has worn off\": \"fetter break\"\n  }\n}\n```\n\nAFTER:\n```json\n{\n  \"game_directory\": \"/path/to/EverQuest\",\n  \"message_announcements\": {\n    \"charm spell has worn off\": \"charm break\",\n    \"Root spell has worn off\": \"root break\",\n    \"Fetter spell has worn off\": \"fetter break\"\n  }\n}\n```\n\nThe game_directory should point to the folder containing the eqlog_*.txt files.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:26:48.748738-06:00","updated_at":"2026-01-06T16:28:49.673883-06:00","closed_at":"2026-01-06T16:28:49.673883-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-qu0","depends_on_id":"QuarmAnnounce-ohe","type":"blocks","created_at":"2026-01-06T08:27:19.906974-06:00","created_by":"daemon"}]}
