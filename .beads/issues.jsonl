{"id":"QuarmAnnounce-19w","title":"Implement precache() method for TtsEngine","description":"In src/audio.rs, add a new async method to pre-synthesize and cache all announcement texts at startup.\n\nAdd this method to the TtsEngine impl block (after new() or new_mock()):\n\n```rust\n/// Pre-synthesizes audio for all given texts and caches them for fast playback\n/// Should be called at startup before any announce() calls\npub async fn precache(\u0026mut self, texts: impl IntoIterator\u003cItem = impl AsRef\u003cstr\u003e\u003e) -\u003e Result\u003c()\u003e {\n    let synth = Arc::clone(\u0026self.synthesizer);\n    let texts: Vec\u003cString\u003e = texts.into_iter().map(|t| t.as_ref().to_string()).collect();\n    \n    // Synthesize all texts in blocking thread (espeak-ng is not thread-safe)\n    let samples_map = tokio::task::spawn_blocking(move || {\n        let synth_guard = synth.blocking_lock();\n        let mut map = HashMap::new();\n        for text in texts {\n            let samples = synthesize_audio(\u0026synth_guard, \u0026text)?;\n            map.insert(text, Arc::new(samples));\n        }\n        Ok::\u003c_, anyhow::Error\u003e(map)\n    })\n    .await\n    .context(\"Failed to spawn blocking task for precache\")?\n    .context(\"Precache synthesis failed\")?;\n    \n    // Store in cache - use Arc::make_mut to get mutable access\n    let cache = Arc::make_mut(\u0026mut self.audio_cache);\n    cache.extend(samples_map);\n    \n    println!(\"Pre-cached {} announcements\", cache.len());\n    Ok(())\n}\n```\n\nKey implementation notes:\n- Takes \u0026mut self because we need to mutate the cache before any clones are made\n- Uses spawn_blocking because espeak-ng synthesis is CPU-bound and not thread-safe\n- Uses Arc::make_mut() to get mutable access to the HashMap (safe before any clones)\n- Print statement helps confirm precaching happened at startup\n\nDepends on: Add audio_cache field to TtsEngine struct","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T17:08:27.636005-06:00","updated_at":"2026-01-06T18:04:09.671047-06:00","closed_at":"2026-01-06T18:04:09.671047-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-19w","depends_on_id":"QuarmAnnounce-ytb","type":"blocks","created_at":"2026-01-06T17:09:27.473014-06:00","created_by":"kaiyao"}]}
{"id":"QuarmAnnounce-1gd","title":"Update announce() to check cache before synthesis","description":"In src/audio.rs, modify the announce() method (line ~88-117) to check the audio cache before falling back to synthesis.\n\nReplace the current synthesis block with cache-first logic:\n\n```rust\npub async fn announce(\u0026self, text: \u0026str) -\u003e Result\u003c()\u003e {\n    // 1. Check cache first, fallback to synthesis if not cached\n    let samples = if let Some(cached) = self.audio_cache.get(text) {\n        // Cache hit - just clone the Arc reference (cheap)\n        Arc::clone(cached)\n    } else {\n        // Cache miss - synthesize on demand (original behavior)\n        let synth = Arc::clone(\u0026self.synthesizer);\n        let text = text.to_string();\n        let samples = tokio::task::spawn_blocking(move || {\n            let synth_guard = synth.blocking_lock();\n            synthesize_audio(\u0026synth_guard, \u0026text)\n        })\n        .await\n        .context(\"Failed to spawn blocking task for synthesis\")?\n        .context(\"TTS synthesis failed\")?;\n        Arc::new(samples)\n    };\n\n    // 2. Acquire semaphore permit ONLY for playback to prevent audio overlap\n    let _permit = self\n        .audio_semaphore\n        .acquire()\n        .await\n        .context(\"Failed to acquire semaphore permit\")?;\n\n    // 3. Play audio (blocking rodio operations)\n    // Note: We need to convert Arc\u003cVec\u003cf32\u003e\u003e to Vec\u003cf32\u003e for play_audio\n    let samples_vec = (*samples).clone();\n    tokio::task::spawn_blocking(move || play_audio(samples_vec))\n        .await\n        .context(\"Failed to spawn blocking task for audio playback\")?\n        .context(\"Audio playback failed\")?;\n\n    Ok(())\n}\n```\n\nKey changes:\n- Check self.audio_cache.get(text) first for O(1) lookup\n- If cached, clone the Arc reference (cheap, not the data)\n- If not cached, fall back to synthesis (maintains backward compatibility)\n- Need to clone the Vec for play_audio since it takes ownership\n\nDepends on: Add audio_cache field to TtsEngine struct","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T17:08:47.590867-06:00","updated_at":"2026-01-06T18:04:09.672146-06:00","closed_at":"2026-01-06T18:04:09.672146-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-1gd","depends_on_id":"QuarmAnnounce-ytb","type":"blocks","created_at":"2026-01-06T17:09:28.60314-06:00","created_by":"kaiyao"}]}
{"id":"QuarmAnnounce-1rh","title":"Call tts_engine.precache() in main.rs after engine creation","description":"In src/main.rs, add a call to precache all announcement texts after creating the TtsEngine.\n\nAfter line 51 (TtsEngine::new), add:\n\n```rust\n// Initialize TTS engine\nlet mut tts_engine = TtsEngine::new(CONFIG_PATH)\n    .await\n    .context(\"Failed to initialize TTS engine\")?;\n\n// Pre-cache all announcement audio for faster playback\ntts_engine\n    .precache(config.message_announcements.values())\n    .await\n    .context(\"Failed to pre-cache announcement audio\")?;\n\nprintln!(\"TTS engine initialized successfully\");\n```\n\nKey changes:\n1. Change `let tts_engine` to `let mut tts_engine` (precache takes \u0026mut self)\n2. Add the precache() call with config.message_announcements.values()\n3. Add error context for precache failure\n\nThe precache call iterates over all announcement values (e.g., 'charm break', 'root break') and synthesizes their audio at startup, so they're ready for instant playback when log matches occur.\n\nDepends on: Implement precache() method for TtsEngine","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T17:08:57.456273-06:00","updated_at":"2026-01-06T18:04:09.673192-06:00","closed_at":"2026-01-06T18:04:09.673192-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-1rh","depends_on_id":"QuarmAnnounce-19w","type":"blocks","created_at":"2026-01-06T17:09:30.468287-06:00","created_by":"kaiyao"}]}
{"id":"QuarmAnnounce-30w","title":"Add find_most_recent_log() helper function","description":"In src/log_monitor.rs, add a new helper function and constants:\n\n1. Add these constants near the top of the file (after existing constants):\n```rust\nconst LOG_FILE_PREFIX: \u0026str = \"eqlog_\";\nconst MTIME_CHECK_INTERVAL: Duration = Duration::from_secs(1);\n```\n\n2. Add a helper function (can be a standalone fn or impl method):\n```rust\n/// Scans the given directory for eqlog_* files and returns the most recently modified one.\n/// Returns None if no matching log files are found.\nfn find_most_recent_log(directory: \u0026Path) -\u003e Result\u003cOption\u003cPathBuf\u003e\u003e {\n    let entries = std::fs::read_dir(directory)\n        .context(format!(\"Failed to read directory: {}\", directory.display()))?;\n    \n    let mut most_recent: Option\u003c(PathBuf, std::time::SystemTime)\u003e = None;\n    \n    for entry in entries.filter_map(|e| e.ok()) {\n        let file_name = entry.file_name();\n        let name_str = file_name.to_string_lossy();\n        \n        if name_str.starts_with(LOG_FILE_PREFIX) {\n            if let Ok(metadata) = entry.metadata() {\n                if let Ok(mtime) = metadata.modified() {\n                    match \u0026most_recent {\n                        None =\u003e most_recent = Some((entry.path(), mtime)),\n                        Some((_, prev_mtime)) if mtime \u003e *prev_mtime =\u003e {\n                            most_recent = Some((entry.path(), mtime));\n                        }\n                        _ =\u003e {}\n                    }\n                }\n            }\n        }\n    }\n    \n    Ok(most_recent.map(|(path, _)| path))\n}\n```\n\nNote: This uses std::fs (sync) which is fine since directory scanning is fast. Add 'use std::path::Path;' if not already imported.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:25:51.286833-06:00","updated_at":"2026-01-06T16:28:49.671541-06:00","closed_at":"2026-01-06T16:28:49.671541-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-30w","depends_on_id":"QuarmAnnounce-ohe","type":"blocks","created_at":"2026-01-06T08:27:19.166692-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-42f","title":"Refactor LogMonitor to store game_directory","description":"In src/log_monitor.rs, modify the LogMonitor struct and its constructor:\n\n1. Change the struct field from log_path to game_directory:\nBEFORE:\n```rust\npub struct LogMonitor {\n    log_path: PathBuf,\n    message_map: HashMap\u003cString, String\u003e,\n    tts_engine: TtsEngine,\n}\n```\n\nAFTER:\n```rust\npub struct LogMonitor {\n    game_directory: PathBuf,\n    message_map: HashMap\u003cString, String\u003e,\n    tts_engine: TtsEngine,\n}\n```\n\n2. Update the constructor (LogMonitor::new):\nBEFORE:\n```rust\npub fn new(config: Config, tts_engine: TtsEngine) -\u003e Self {\n    Self {\n        log_path: PathBuf::from(config.log_file_path),\n        message_map: config.message_announcements,\n        tts_engine,\n    }\n}\n```\n\nAFTER:\n```rust\npub fn new(config: Config, tts_engine: TtsEngine) -\u003e Self {\n    Self {\n        game_directory: PathBuf::from(config.game_directory),\n        message_map: config.message_announcements,\n        tts_engine,\n    }\n}\n```\n\n3. Update test helper create_test_monitor() to use game_directory instead of log_path.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:26:08.71505-06:00","updated_at":"2026-01-06T16:28:49.672954-06:00","closed_at":"2026-01-06T16:28:49.672954-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-42f","depends_on_id":"QuarmAnnounce-ohe","type":"blocks","created_at":"2026-01-06T08:27:19.34621-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-ecq","title":"Update tests for audio cache functionality","description":"In src/audio.rs, update existing tests and add new tests for the precache functionality.\n\n1. Verify new_mock() initializes with empty cache (already done in previous task)\n\n2. Add a test for precache functionality:\n\n```rust\n/// Test that precache() successfully caches announcement texts\n#[tokio::test]\nasync fn test_precache_caches_announcements() {\n    let mut engine = TtsEngine::new(CONFIG_PATH)\n        .await\n        .expect(\"Failed to initialize TtsEngine\");\n    \n    let announcements = vec![\"charm break\", \"root break\"];\n    let result = engine.precache(announcements.iter().copied()).await;\n    \n    assert!(result.is_ok(), \"Precache should succeed\");\n    \n    // Verify cache contains the announcements\n    assert!(engine.audio_cache.get(\"charm break\").is_some());\n    assert!(engine.audio_cache.get(\"root break\").is_some());\n}\n\n/// Test that announce() uses cached audio (no synthesis needed)\n#[tokio::test]\nasync fn test_announce_uses_cached_audio() {\n    let mut engine = TtsEngine::new(CONFIG_PATH)\n        .await\n        .expect(\"Failed to initialize TtsEngine\");\n    \n    // Precache the announcement\n    engine.precache([\"test announcement\"]).await\n        .expect(\"Precache should succeed\");\n    \n    // Announce should succeed and be faster since it uses cache\n    let result = engine.announce(\"test announcement\").await;\n    assert!(result.is_ok(), \"Announce with cached audio should succeed\");\n}\n```\n\n3. Ensure existing tests still pass - they exercise the fallback synthesis path since they don't call precache()\n\nDepends on: Add audio_cache field to TtsEngine struct, Implement precache() method for TtsEngine","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T17:09:14.304413-06:00","updated_at":"2026-01-06T18:05:36.470395-06:00","closed_at":"2026-01-06T18:05:36.470395-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-ecq","depends_on_id":"QuarmAnnounce-ytb","type":"blocks","created_at":"2026-01-06T17:09:32.503309-06:00","created_by":"kaiyao"},{"issue_id":"QuarmAnnounce-ecq","depends_on_id":"QuarmAnnounce-19w","type":"blocks","created_at":"2026-01-06T17:09:34.798107-06:00","created_by":"kaiyao"}]}
{"id":"QuarmAnnounce-n5s","title":"Update tests for directory-based monitoring","description":"In src/log_monitor.rs, update the test helper and tests to work with the new structure:\n\n1. Update create_test_monitor() helper (around line 185):\nBEFORE:\n```rust\nfn create_test_monitor(message_map: HashMap\u003cString, String\u003e) -\u003e LogMonitor {\n    LogMonitor {\n        log_path: PathBuf::from(\"/test/path\"),\n        message_map,\n        tts_engine: TtsEngine::new_mock().expect(\"Failed to create mock TTS engine\"),\n    }\n}\n```\n\nAFTER:\n```rust\nfn create_test_monitor(message_map: HashMap\u003cString, String\u003e) -\u003e LogMonitor {\n    LogMonitor {\n        game_directory: PathBuf::from(\"/test/game\"),\n        message_map,\n        tts_engine: TtsEngine::new_mock().expect(\"Failed to create mock TTS engine\"),\n    }\n}\n```\n\n2. Optionally add a new test for find_most_recent_log():\n```rust\n#[test]\nfn test_find_most_recent_log_no_files() {\n    // Create a temp directory with no eqlog files\n    let temp_dir = std::env::temp_dir().join(\"test_no_logs\");\n    std::fs::create_dir_all(\u0026temp_dir).unwrap();\n    \n    let result = find_most_recent_log(\u0026temp_dir).unwrap();\n    assert!(result.is_none());\n    \n    std::fs::remove_dir_all(\u0026temp_dir).ok();\n}\n```\n\nNote: The existing process_one_batch tests don't need changes since they test the line processing logic which is unchanged.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:27:13.771128-06:00","updated_at":"2026-01-06T16:58:57.078263-06:00","closed_at":"2026-01-06T16:58:57.078263-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-n5s","depends_on_id":"QuarmAnnounce-42f","type":"blocks","created_at":"2026-01-06T08:27:20.082524-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-ohe","title":"Update Config struct to use game_directory","description":"In src/main.rs, modify the Config struct (around line 16):\n\nBEFORE:\n```rust\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct Config {\n    pub log_file_path: String,\n    pub message_announcements: HashMap\u003cString, String\u003e,\n}\n```\n\nAFTER:\n```rust\n#[derive(serde::Deserialize, Debug, Clone)]\npub struct Config {\n    pub game_directory: String,\n    pub message_announcements: HashMap\u003cString, String\u003e,\n}\n```\n\nAlso update the println! on line 45 from 'Log file:' to 'Game directory:' and change config.log_file_path to config.game_directory.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:25:31.961655-06:00","updated_at":"2026-01-06T16:28:37.090706-06:00","closed_at":"2026-01-06T16:28:37.090706-06:00","close_reason":"Closed"}
{"id":"QuarmAnnounce-pf1","title":"Implement mtime check loop with file switching","description":"In src/log_monitor.rs, rewrite the start_monitoring() method to:\n\n1. Track last mtime check time using std::time::Instant\n2. Find and open the most recent log file on startup\n3. Check for file switches every 1 second (when at EOF)\n\nNew start_monitoring() logic:\n```rust\npub async fn start_monitoring(\u0026self) -\u003e Result\u003c()\u003e {\n    println!(\"Scanning directory: {:?}\", self.game_directory);\n    \n    loop {\n        // Find the most recent log file\n        let log_path = match find_most_recent_log(\u0026self.game_directory)? {\n            Some(path) =\u003e path,\n            None =\u003e {\n                println!(\"No eqlog_* files found, waiting...\");\n                tokio::time::sleep(Duration::from_secs(1)).await;\n                continue;\n            }\n        };\n        \n        println!(\"Monitoring: {:?}\", log_path);\n        \n        // Open and seek to end\n        let file = tokio::fs::File::open(\u0026log_path).await\n            .context(format!(\"Failed to open: {}\", log_path.display()))?;\n        let mut reader = BufReader::new(file);\n        reader.seek(SeekFrom::End(0)).await?;\n        \n        // Monitor this file until a different file becomes most recent\n        let mut last_mtime_check = std::time::Instant::now();\n        \n        loop {\n            match self.process_one_batch(\u0026mut reader, \u0026mut String::new()).await? {\n                Some(announcements) =\u003e {\n                    // Spawn announcements...\n                    for announcement in announcements {\n                        let engine = self.tts_engine.clone();\n                        tokio::spawn(async move {\n                            if let Err(e) = engine.announce(\u0026announcement).await {\n                                eprintln!(\"Announce failed: {}\", e);\n                            }\n                        });\n                    }\n                }\n                None =\u003e {\n                    // EOF - check if we should switch files\n                    if last_mtime_check.elapsed() \u003e= MTIME_CHECK_INTERVAL {\n                        last_mtime_check = std::time::Instant::now();\n                        if let Some(new_path) = find_most_recent_log(\u0026self.game_directory)? {\n                            if new_path != log_path {\n                                println!(\"Switching to: {:?}\", new_path);\n                                break; // Break inner loop to reopen with new file\n                            }\n                        }\n                    }\n                    tokio::time::sleep(IDLE_RETRY_DELAY).await;\n                }\n            }\n        }\n    }\n}\n```\n\nKey points:\n- Outer loop handles file discovery/switching\n- Inner loop handles reading from current file\n- Check mtime only when at EOF and 1 second has elapsed\n- When switching, break inner loop to restart with new file","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:26:32.689246-06:00","updated_at":"2026-01-06T16:29:06.486355-06:00","closed_at":"2026-01-06T16:29:06.486355-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-pf1","depends_on_id":"QuarmAnnounce-30w","type":"blocks","created_at":"2026-01-06T08:27:19.533864-06:00","created_by":"daemon"},{"issue_id":"QuarmAnnounce-pf1","depends_on_id":"QuarmAnnounce-42f","type":"blocks","created_at":"2026-01-06T08:27:19.73819-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-qu0","title":"Update config.json to use game_directory","description":"Update config.json to use the new game_directory field:\n\nBEFORE:\n```json\n{\n  \"log_file_path\": \"./eqlog_YourCharacter_pq.proj.txt\",\n  \"message_announcements\": {\n    \"charm spell has worn off\": \"charm break\",\n    \"Root spell has worn off\": \"root break\",\n    \"Fetter spell has worn off\": \"fetter break\"\n  }\n}\n```\n\nAFTER:\n```json\n{\n  \"game_directory\": \"/path/to/EverQuest\",\n  \"message_announcements\": {\n    \"charm spell has worn off\": \"charm break\",\n    \"Root spell has worn off\": \"root break\",\n    \"Fetter spell has worn off\": \"fetter break\"\n  }\n}\n```\n\nThe game_directory should point to the folder containing the eqlog_*.txt files.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T08:26:48.748738-06:00","updated_at":"2026-01-06T16:28:49.673883-06:00","closed_at":"2026-01-06T16:28:49.673883-06:00","close_reason":"Closed","dependencies":[{"issue_id":"QuarmAnnounce-qu0","depends_on_id":"QuarmAnnounce-ohe","type":"blocks","created_at":"2026-01-06T08:27:19.906974-06:00","created_by":"daemon"}]}
{"id":"QuarmAnnounce-ytb","title":"Add audio_cache field to TtsEngine struct","description":"In src/audio.rs, add a new field to the TtsEngine struct:\n\n```rust\naudio_cache: Arc\u003cHashMap\u003cString, Arc\u003cVec\u003cf32\u003e\u003e\u003e\u003e\n```\n\nSteps:\n1. Add 'use std::collections::HashMap;' to imports if not present\n2. Add the audio_cache field to the TtsEngine struct (line ~17-20)\n3. In the Clone impl (line ~22-29), add audio_cache cloning: `audio_cache: Arc::clone(\u0026self.audio_cache)`\n4. In TtsEngine::new() (line ~33-59), initialize with empty cache: `audio_cache: Arc::new(HashMap::new())`\n5. In TtsEngine::new_mock() (line ~64-85), also initialize with empty cache\n\nThe Arc\u003cVec\u003cf32\u003e\u003e is used for the samples to avoid expensive clones during playback - we just clone the Arc reference instead of the entire audio buffer.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-06T17:08:14.344026-06:00","updated_at":"2026-01-06T18:04:09.66888-06:00","closed_at":"2026-01-06T18:04:09.66888-06:00","close_reason":"Closed"}
